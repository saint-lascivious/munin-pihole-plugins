#!/usr/bin/env bash

# munin-pihole-plugins
# saint-lascivious (Hayden Pearce) ©2022

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# Contact: munin-pihole-plugins@sainternet.xyz

# munin-pihole-plugins version
# must follow 8 character major.minor.micro scheme
VERSION="07.04.00"

# source any external variables from munin-pihole-plugins.conf
# somewhat of a security risk honestly, i don't particularly
# like using . but if someone can write to /etc then you most
# certainly have bigger problems
# hey saint, what in kitten's whiskers is this bullshit all about?
# good question, see the following as to why we dance this stupid
# dance pseudo-sourcing /dev/null for shellcheck
# https://github.com/koalaman/shellcheck/wiki/SC1090
# tl;dr: it's dumb
external_config_dir="${EXTERNAL_CONFIG_DIR:-/etc/munin-pihole-plugins}"
external_config_file="${EXTERNAL_CONFIG_FILE:-munin-pihole-plugins.conf}"
if [[ -f "${external_config_dir}/${external_config_file}" ]]; then
    # shellcheck source=/dev/null
    . "${external_config_dir}/${external_config_file}"
fi

# environment variables with overrides
branch="${BRANCH:-master}"
dns_port="${DNS_PORT:-53}"
dns_server="${DNS_SERVER:-208.67.222.222}"
force_update_plugin_config="${FORCE_UPDATE_PLUGIN_CONFIG:-false}"
hold_duration="${HOLD_DURATION:-0}"
ignore_pihole_on_host="${IGNORE_PIHOLE_ON_HOST:-false}"
install_plugins="${INSTALL_PLUGINS:-true}"
install_script="${INSTALL_SCRIPT:-true}"
install_webserver="${INSTALL_WEBSERVER:-true}"
lighttpd_webroot="${LIGHTTPD_WEBROOT:-/var/www/html}"
munin_branch="${MUNIN_BRANCH:-stable}"
munin_dir="${MUNIN_DIR:-/etc/munin}"
munin_config_dir="${MUNIN_CONFIG_DIR:-${munin_dir}/munin-conf.d}"
munin_plugin_dir="${MUNIN_PLUGIN_DIR:-/usr/share/munin/plugins}"
node_plugin_dir="${NODE_PLUGIN_DIR:-${munin_dir}/plugins}"
plugin_config_dir="${PLUGIN_CONFIG_DIR:-${munin_dir}/plugin-conf.d}"
plugin_list="${PLUGIN_LIST:-blocked cache cache_by_type clients percent privacy queries queries_by_type replies_by_type status unique_domains}"
proxy_config_dir="${PROXY_CONFIG_DIR:-/etc/lighttpd}"
script_dir="${SCRIPT_DIR:-/usr/local/bin}"
show_colour="${SHOW_COLOR:-${SHOW_COLOUR:-true}}"
show_header="${SHOW_HEADER:-true}"
skip_dependency_check="${SKIP_DEPENDENCY_CHECK:-false}"
update_self="${UPDATE_SELF:-true}"
verbosity_level="${VERBOSITY_LEVEL:-3}"

# environment variables without
gnu_gpl_v3="https://raw.githubusercontent.com/saint-lascivious/munin-pihole-plugins/master/LICENSE.md"
man_dir="/usr/local/man/man1"
proxy_repo="https://raw.githubusercontent.com/saint-lascivious/lighttpd-external-munin-proxy"

# munin-pihole-plugins dependency lists
# basic dependencies assumed to exist with limited/no question:
# cat, date, dirname, echo, grep, ln, ls, mv, rm, sed, tput
# readlink
# note: the spaces at the ends of the environment variable
# values for *_dependencies are intentional and must be
# retained for the sake of easy string concat
plugin_dependencies="curl munin-node "
script_dependencies="init-system-helpers wget "
webserver_dependencies="lighttpd munin "

# munin-pihole-plugins services lists
# note: the spaces at the ends of the environment variable
# values for *_services are intentional and must be
# retained for the sake of easy string concat
plugin_services="munin-node "
webserver_services="lighttpd munin "

# misc.
current_dir="$(dirname "$(readlink -f "$0")")"
rfc3339_date="$(date --rfc-3339="seconds")"
terminal_height="$(stty size | cut -d " " -f1)"
terminal_width="$(stty size | cut -d " " -f2)"

# we just won't talk about this
temp_dir="${TMPDIR:-${TEMP:-${TMP:-/tmp}}}"

# fallbacks for out of range or unexpected hold durations
# set to 0 when lower than 0, 5 when higher than 5
# set to 0 if it's something entirely unexpected
if [[ "${hold_duration}" =~ ^(-)?[0-9]+$ ]]; then
    if [[ "${hold_duration}" -lt "0" ]]; then
        hold_duration="0"
    else
        if [[ "${hold_duration}" -gt "5" ]]; then
            hold_duration="5"
        fi
    fi
else
    hold_duration="0"
fi

# fallbacks for out of range or unexpected verbosity levels
# set to 0 when lower than 0, 4 when higher than 4
# set to 3 if it's something entirely unexpected
if [[ "${verbosity_level}" =~ ^(-)?[0-9]+$ ]]; then
    if [[ "${verbosity_level}" -lt "0" ]]; then
        verbosity_level="0"
    else
        if [[ "${verbosity_level}" -gt "4" ]]; then
            verbosity_level="4"
        fi
    fi
else
    verbosity_level="4"
fi

# define colours for later use, if supported
# allow the display of colours to be disabled
if [[ -t "1" ]] && [[ $(tput colors) -ge "8" ]]; then
    if [[ "${show_colour}" == "true" ]]; then
        WHITE="\\e[97m"
        RED="\\e[31m"
        ORANGE="\\e[33m"
        YELLOW="\\e[93m"
        GREEN="\\e[32m"
        BLUE="\\e[94m"
        INDIGO="\\e[34m"
        VIOLET="\\e[35m"
        RESET="\\e[0m"
    else
        WHITE=""
        RED=""
        ORANGE=""
        YELLOW=""
        GREEN=""
        BLUE=""
        INDIGO=""
        VIOLET=""
        RESET=""
    fi
else
    WHITE=""
    RED=""
    ORANGE=""
    YELLOW=""
    GREEN=""
    BLUE=""
    INDIGO=""
    VIOLET=""
    RESET=""
fi

# check for the existence of (a) required command(s)
# throws an error describing the command name when unsatisfied
# checks are considered critical (exit on failure) unless the
# optional param "noncritical" is passed
i_can_has() {
    burgers="$1"
    for cheezburger in ${burgers}; do
        if [[ ! -x "$(command -v "${cheezburger}")" ]]; then
            if [[ "$2" != "noncritical" ]]; then
                reverberate "error" "The required command \"${cheezburger}\" was not found"
                reverberate "failure" "${cheezburger}"
                reverberate "exit" "1"
            else
                reverberate "error" "The command \"${cheezburger}\" was not found"
                reverberate "failure" "${cheezburger}"
                return "127"
            fi
        fi
    done
}

# simple privilege check
check_privilege() {
    if [[ ! "${EUID}" -eq "0" ]];then
        if i_can_has "sudo" "noncritical"; then
            exec sudo -E bash "$0" "$@"
            exit "$?"
        else
            reverberate "info" "Install \"sudo\" (recommended), or run $0 as root"
            reverberate "exit" "0"
        fi
    fi
}

# there are ways of doing this without spawning a child script
# but they all suck, and/or are extremely convoluted
# this approach is a trade-off
update_script() {
    cat > "${temp_dir}/.munin-pihole-plugins_update" << EOF
#!/usr/bin/env bash

# .munin-pihole-plugins_update
# saint-lascivious (Hayden Pearce) 2022
# saint@sainternet.xyz

VERSION="${VERSION}"

# source current munin-pihole-plugins script to re-use its functions
# and environment
if [[ -f "${current_dir}/munin-pihole-plugins" ]]; then
    . "${current_dir}/munin-pihole-plugins"
else
    # this should never happen
    # but if it does we need to abort
    exit 1
fi

# a simple self update function for the munin-pihole-plugins script
update_now() {
    reverberate "header"
    reverberate "runtime_disclaimer"
    reverberate "info" "Updating the munin-pihole-plugins script"
    download "${plugin_domain}" -O "${current_dir}/munin-pihole-plugins"
    reverberate "success" "${current_dir}/munin-pihole-plugins installed"
    chmod +x "${current_dir}/munin-pihole-plugins" || return
    reverberate "footer"
    reverberate "info" "Restarting munin-pihole-plugins after update"
    clear
    exec env UPDATE_SELF="false" /bin/bash "$0" "$@"
}

update_now
EOF
    chmod +x "${temp_dir}/.munin-pihole-plugins_update"
    exec /bin/bash "${temp_dir}/.munin-pihole-plugins_update"
}

# user request, variable output delay
# many actions are near instantaneous, add some dwell time (default 0) after
# output
hold_up() {
    if [[ "${verbosity_level}" -ge "1" ]] && [[ "${hold_duration}" -gt "0" ]]; then
        sleep "${hold_duration}"
    fi
}

# echo wrapper handling verbosity levels and common output
# 0 - silent
# 1 - + errors
# 2 - ++ warnings/questions
# 3 - +++ header/information/runtime disclaimer
# 4 - ++++ additional information/config examples/failure/misc./success
# the header is truly and utterly obnoxious, probably my worst work yet
# it is a thing of beauty and absolute perfection
reverberate() {
    case "$1" in
        "additional_info")
            if [[ "${verbosity_level}" -ge "4" ]]; then
                echo -e "\\n  [${WHITE}ℹ${RESET}] ${GREEN}$2${RESET}"
                hold_up
            fi
        ;;
        "config")
            if [[ "${verbosity_level}" -ge "4" ]]; then
                if [[ -f "${script_dir}/munin-pihole-plugins" ]]; then
                    config_text="  ${WHITE}munin-pihole-plugins --configure $2${RESET} VALUE"
                else
                    config_text="  ${WHITE}export $2=\"VALUE\"${RESET}"
                fi
                echo -e "${config_text}"
                hold_up
            fi
        ;;
        "error")
            if [[ "${verbosity_level}" -ge "1" ]]; then
                echo -e "\\n  [${RED}!${RESET}] ${RED}$2${RESET}"
                hold_up
            fi
        ;;
        "exit")
            if [[ "${verbosity_level}" -ge "1" ]]; then
                echo -e "\\n  [${RED}!${RESET}] ${RED}Exiting $0${RESET}"
            fi
            if [[ -n "$2" ]] && [[ "$2" =~ ^[0-9]+$ ]]; then
                exit_value="$2"
            else
                exit_value="0"
            fi
            exit "${exit_value}"
        ;;
        "failure")
            if [[ "${verbosity_level}" -ge "4" ]]; then
                echo -e "  [${RED}✗${RESET}] $2"
                hold_up
            fi
        ;;
        "footer")
            if [[ "${verbosity_level}" -ge "3" ]]; then
                echo -e "\\n  [${WHITE}ℹ${RESET}] ${GREEN}Done${RESET}\\n"
            fi
        ;;
        "header")
            if [[ "${verbosity_level}" -ge "3" ]]; then
                if [[ "${show_header}" == "true" ]]; then
                    if [[ "${terminal_height}" -ge "12" ]] && [[ "${terminal_width}" -ge "80" ]]; then
                        echo -e "${RED}  ${rfc3339_date}                 _           saint-lascivious ©2022  ${RESET}
${ORANGE}                   _ __ ___   _   _  _ __  (_) _ __                             ${RESET}
${YELLOW}                  | '_ \` ${RED}_${YELLOW} \\ | | | || '_ \\ | || '${RED}_${YELLOW} \\  ${RED}_${ORANGE}_${YELLOW}_${GREEN}_${BLUE}_${INDIGO}_${YELLOW}                    ${RESET}
${GREEN}                  | | | ${ORANGE}|${ORANGE} ${RED}|${GREEN} || |_| || | | || || ${ORANGE}|${GREEN} ${RED}|${GREEN} |${RED}|${ORANGE}_${YELLOW}_${GREEN}_${BLUE}_${INDIGO}_${VIOLET}_|${GREEN}     v${VERSION}     ${RESET}
${BLUE}        _  _      |_| |_${YELLOW}|${BLUE} ${ORANGE}|${BLUE}_| \\__,_||_| |_||_||_${YELLOW}|${BLUE} ${ORANGE}|${BLUE}_|             _             ${RESET}
${INDIGO} _ __  (_)| |__    ___  ${GREEN}|${INDIGO} ${YELLOW}|${INDIGO}  ___          _ __  ${GREEN}|${INDIGO} ${YELLOW}|${INDIGO} _   _   __ _ (_) _ __   ___ ${RESET}
${VIOLET}| '_ \\ | || '_ \\  / _ \\ ${BLUE}|${VIOLET} ${GREEN}|${VIOLET} / _ \\ ${RED}_${ORANGE}_${YELLOW}_${GREEN}_${BLUE}_${INDIGO}_${VIOLET} | '_ \\ ${BLUE}|${VIOLET} ${GREEN}|${VIOLET}| | | | / _\` || || '_ \\ / __|
${RED}| |_) || || | | || (_) |${INDIGO}|${RED} ${BLUE}|${RED}|  __/${RED}|${ORANGE}_${YELLOW}_${GREEN}_${BLUE}_${INDIGO}_${VIOLET}_|${RED}| |_) |${INDIGO}|${RED} ${BLUE}|${RED}| |_| || (_| || || | | |\\__ \\
${ORANGE}| .__/ |_||_| |_| \\___/ ${VIOLET}|_${INDIGO}|${ORANGE} \\___|        | .__/ ${VIOLET}|_${INDIGO}|${ORANGE} \\__,_| \\__, ||_||_| |_||___/${RESET}
${YELLOW}|_|                                      |_|               |___/                ${RESET}
${GREEN}                                                                                ${RESET}
${BLUE} ${RED}M${ORANGE}u${YELLOW}n${GREEN}i${BLUE}n${INDIGO} ${VIOLET}p${RED}l${ORANGE}u${YELLOW}g${GREEN}i${BLUE}n${INDIGO}s${VIOLET} ${RED}a${ORANGE}n${YELLOW}d${GREEN} ${BLUE}m${INDIGO}a${VIOLET}n${RED}a${ORANGE}g${YELLOW}e${GREEN}m${BLUE}e${INDIGO}n${VIOLET}t${RED} ${ORANGE}s${YELLOW}c${GREEN}r${BLUE}i${INDIGO}p${VIOLET}t${RED} ${ORANGE}f${YELLOW}o${GREEN}r${BLUE} ${INDIGO}m${VIOLET}o${RED}n${ORANGE}i${YELLOW}t${GREEN}o${BLUE}r${INDIGO}i${VIOLET}n${RED}g${ORANGE} ${YELLOW}v${GREEN}a${BLUE}r${INDIGO}i${VIOLET}o${RED}u${ORANGE}s${YELLOW} ${GREEN}P${BLUE}i${INDIGO}-${VIOLET}h${RED}o${ORANGE}l${YELLOW}e${GREEN}®${BLUE} ${INDIGO}s${VIOLET}t${RED}a${ORANGE}t${YELLOW}i${GREEN}s${BLUE}t${INDIGO}i${VIOLET}c${RED}s${BLUE} ${RESET}"
                    fi
                fi
            fi
        ;;
        "info")
            if [[ "${verbosity_level}" -ge "3" ]]; then
                echo -e "\\n  [${WHITE}ℹ${RESET}] ${GREEN}$2${RESET}"
                hold_up
            fi
        ;;
        "question")
            if [[ "${verbosity_level}" -ge "2" ]]; then
                echo -e "\\n  [${BLUE}?${BLUE}] ${BLUE}$2${RESET}"
            fi
        ;;
        "runtime_disclaimer")
            if [[ "${verbosity_level}" -ge "3" ]]; then
                echo -e "\\n  This program comes with ${RED}ABSOLUTELY NO WARRANTY${RESET}; for details type
  \"munin-pihole-plugins --show --warranty\"
\\n  This is ${GREEN}FREE SOFTWARE${RESET}, and you are welcome to redistribute it
  under certain conditions; for details type
  \"munin-pihole-plugins --show --conditions\"
\\n  To read the full GNU GPL v3 license text, type
  \"munin-pihole-plugins --show --gnu-gpl\""
                hold_up
            fi
        ;;
        "success")
            if [[ "${verbosity_level}" -ge "4" ]]; then
                echo -e "  [${GREEN}✓${RESET}] $2"
                hold_up
            fi
        ;;
        "warning")
            if [[ "${verbosity_level}" -ge "2" ]]; then
                echo -e "\\n  [${YELLOW}⚠${RESET}] ${YELLOW}$2${RESET}"
                hold_up
            fi
        ;;
        *)
            if [[ "${verbosity_level}" -ge "4" ]]; then
                echo -e "  $1"
                hold_up
            fi
        ;;
    esac
}

# is this a pihole host?
# and if so, can we support its API?
# yes - i am aware that pihole_version is...non optimal, there is probably
# going to be a much better way to strip the text and formatting from pihole's
# version output
check_pihole() {
    reverberate "info" "Checking if this is a Pi-hole® host"
    if i_can_has "pihole" "noncritical"; then
        pihole_version="$(pihole -v | grep "Pi-hole" | sed 's/Pi-hole version is v//; s/[(][^)]*[)]//; s/[^.0-9]*//g')"
        # shellcheck disable=SC2071
        if [[ "${pihole_version}" > "6" ]]; then
            if [[ "${ignore_pihole_on_host}" != "false" ]]; then
                reverberate "error" "Incompatible Pi-hole® version v${pihole_version}"
                reverberate "info" "Supported Pi-hole® versions ≤ v5.*"
                reverberate "exit" "1"
            else
                reverberate "info" "Ignoring Pi-hole® version v${pihole_version}"
                pihole_on_host="false"
            fi
        else
            reverberate "success" "$(command -v pihole) v${pihole_version}"
            pihole_on_host="true"
        fi
    else
        reverberate "failure" "pihole"
        pihole_on_host="false"
    fi
}

# basic dependency handling with dpkg-query and apt
# can be disabled with SKIP_DEPENDENCY_CHECK set to any value other than false
install_dependencies() {
    if [[ "${install_plugins}" == "true" ]]; then
        dependency_list+="${plugin_dependencies}"
    fi
    if [[ "${install_script}" == "true" ]]; then
        dependency_list+="${script_dependencies}"
    fi
    if [[ "${install_webserver}" == "true" ]]; then
        dependency_list+="${webserver_dependencies}"
    fi
    if i_can_has "dpkg-query"; then
        if i_can_has "apt"; then
            reverberate "additional_info" "Checking for required dependencies"
            for dependency_id in ${dependency_list}; do
                package_query="$(dpkg-query -W --showformat='${Status}\n' "${dependency_id}" | grep "install ok installed")"
                if [[ -n "${package_query}" ]]; then
                    reverberate "success" "${dependency_id}"
                else
                    reverberate "failure" "${dependency_id}"
                    reverberate "additional_info" "Installing required package ${dependency_id}"
                    if [[ "${verbosity_level}" -gt "0" ]]; then
                        apt install -qq "${dependency_id}"
                    else
                        apt install -qq "${dependency_id}" > /dev/null 2>&1
                    fi
                    reverberate "success" "${dependency_id}"
                fi
            done
        fi
    fi
}

# simple wget wrapper
download() {
    if i_can_has "wget"; then
        if [[ "${verbosity_level}" -ge "4" ]]; then
            wget -q --show-progress "$@" || return
            hold_up
        else
            wget -q "$@" || return
        fi
    fi
}

# installs a related project lighttpd-external-munin-proxy
# backup any existing non-zero lighttpd external.conf if no backup exists
# safely merging any existing external.conf properties without conflict
# would be tedious and annoying, and is out of scope at this point
configure_proxy() {
    proxy_config="${proxy_config_dir}/external.conf"
    if [[ -d "${proxy_config_dir}" ]]; then
        reverberate "info" "Installing lighttpd-external-munin-proxy"
        if [[ -s "${proxy_config}" ]]; then
            if [[ ! -f "${proxy_config}.orig" ]]; then
                reverberate "info" "Saving the original lighttpd external.conf file"
                mv "${proxy_config}" "${proxy_config}.orig" || return
                reverberate "additional_info" "The original lighttpd external.conf file was saved to"
                reverberate "success" "${proxy_config}.orig"
            fi
        fi
        if [[ "${munin_branch}" == "stable" ]]; then
            download "${proxy_repo}/master/etc/lighttpd/external.conf" -O "${proxy_config}"
        else
            if [[ "${munin_branch}" == "latest" ]]; then
                download "${proxy_repo}/latest/etc/lighttpd/external.conf" -O "${proxy_config}"
            else
                reverberate "error" "Invalid Munin branch"
                reverberate "failure" "${munin_branch}"
                reverberate "additional_info" "Valid Munin branches are"
                reverberate "success" "latest"
                reverberate "success" "stable"
                reverberate "exit" "1"
            fi
        fi
        reverberate "info" "A copy of lighttpd-external-munin-proxy was installed"
        reverberate "success" "${proxy_config}"
    else
        reverberate "error" "No lighttpd configuration directory found"
        reverberate "failure" "${proxy_config_dir}"
        reverberate "additional_info" "If this directory is located at a different path try"
        reverberate "config" "PROXY_CONFIG_DIR"
        reverberate "exit" "1"
    fi
}

# configure the munin monitoring environment
# two different approaches may be used to set the graph strategy depending on
# the existence of the munin_config_dir
# if it is not found munin-pihole-plugins will attempt to edit the munin.conf
# file directly
configure_munin() {
    if [[ -d "${munin_config_dir}" ]]; then
        if [[ ! -f "${munin_config_dir}/99-graph-strategy.conf" ]]; then
            reverberate "info" "Configuring munin webserver graph strategy"
            download "${plugin_repo}/etc/munin/munin-conf.d/99-graph-strategy.conf" -P "${munin_config_dir}"
            reverberate "success" "${munin_config_dir}/99-graph-strategy.conf"
        fi
    else
        if [[ -d "${munin_dir}" ]]; then
            if [[ -f "${munin_dir}/munin.conf" ]]; then
                reverberate "info" "Attempting fallback configuration editing munin.conf directly"
                sed -i "s/^#graph_strategy cron/graph_strategy cgi/g" "${munin_dir}/munin.conf" || return
                reverberate "success" "graph_strategy cgi"
                sed -i "s/^#html_strategy cron/html_strategy cgi/g" "${munin_dir}/munin.conf" || return
                reverberate "success" "html_strategy cgi"
            else
                reverberate "error" "No munin.conf file found"
                reverberate "failure" "${munin_dir}/munin.conf"
                reverberate "additional_info" "If this file is located at a different path try"
                reverberate "config" "MUNIN_DIR"
                reverberate "exit" "1"
            fi
        else
            reverberate "error" "No Munin directory found"
            reverberate "failure" "${munin_dir}"
            reverberate "additional_info" "If this directory is located at a different path try"
            reverberate "config" "MUNIN_DIR"
            reverberate "exit" "1"
        fi
        reverberate "error" "No Munin configuration directory found"
        reverberate "failure" "${munin_config_dir}"
        reverberate "additional_info" "If this directory is located at a different path try"
        reverberate "config" "MUNIN_CONFIG_DIR"
        reverberate "exit" "1"
    fi
}

# remove all existing munin-pihole-plugins plugins and symbolic links
# munin will reap abandoned plugin .rrd files itself
# legacy plugins names are retained so we don't leave any orphaned plugins
# behind from ancient versions of munin-pihole-plugins, and/or switching from
# the individual plugins to the monolithic plugin
uninstall_plugins() {
    all_plugins="blocked blockrate cache cacheinfo cacherate cache_by_type cache_info clients debug hits percent privacy queries queries_by_type reply replies_by_type status unique unique_domains"
    if [[ -d "${munin_plugin_dir}" ]]; then
        reverberate "info" "Removing any existing munin-pihole-plugins plugin(s)"
        if [[ -f "${munin_plugin_dir}/pihole_" ]]; then
            rm "${munin_plugin_dir}/pihole_" || return
            reverberate "success" "${munin_plugin_dir}/pihole_ removed"
        fi
        for plugin_id in ${all_plugins}; do
            if [[ -f "${munin_plugin_dir}/pihole_${plugin_id}" ]]; then
                rm "${munin_plugin_dir}/pihole_${plugin_id}" || return
                reverberate "success" "${munin_plugin_dir}pihole_${plugin_id} removed"
            fi
        done
    else
        reverberate "warning" "No Munin plugin directory found"
        reverberate "failure" "${munin_plugin_dir}"
        reverberate "additional_info" "If this directory is located at a different path try"
        reverberate "config" "MUNIN_PLUGIN_DIR"
    fi
    if [[ -d "${node_plugin_dir}" ]]; then
        reverberate "info" "Removing any existing munin-pihole-plugins symbolic links"
        for plugin_id in ${all_plugins}; do
            if [[ -h "${node_plugin_dir}/pihole_${plugin_id}" ]]; then
                rm "${node_plugin_dir}/pihole_${plugin_id}" || return
                reverberate "success" "${node_plugin_dir}/pihole_${plugin_id} removed"
            fi
        done
    else
        reverberate "warning" "No Munin node plugin directory found"
        reverberate "failure" "${node_plugin_dir}"
        reverberate "additional_info" "If this directory is located at a different path try"
        reverberate "config" "NODE_PLUGIN_DIR"
    fi
}

# installs munin-pihole-plugins plugins and symbolic links
# plugins to be installed can be configured using the PLUGIN_LIST variable
install_plugins() {
    if [[ -d "${munin_plugin_dir}" ]]; then
        if [[ -d "${node_plugin_dir}" ]]; then
            reverberate "info" "Installing the munin-pihole-plugins plugin"
            download "${plugin_repo}/usr/share/munin/plugins/pihole_" -P "${munin_plugin_dir}"
            chmod +x "${munin_plugin_dir}/pihole_" || return
            reverberate "additional_info" "A copy of the munin-pihole-plugins plugin was installed"
            reverberate "success" "${munin_plugin_dir}/pihole_"
            reverberate "info" "Creating selected munin-pihole-plugins plugin symbolic links"
            for plugin_id in ${plugin_list}; do
                ln -s "${munin_plugin_dir}/pihole_" "${node_plugin_dir}/pihole_${plugin_id}" || return
                reverberate "success" "${node_plugin_dir}/pihole_${plugin_id}"
            done
        else
            reverberate "error" "No Munin node plugin directory found"
            reverberate "failure" "${node_plugin_dir}"
            reverberate "additional_info" "If this directory is located at a different path try"
            reverberate "config" "NODE_PLUGIN_DIR"
            reverberate "exit" "1"
        fi
    else
        reverberate "error" "No Munin plugin directory found"
        reverberate "failure" "${munin_plugin_dir}"
        reverberate "additional_info" "If this directory is located at a different path try"
        reverberate "config" "MUNIN_PLUGIN_DIR"
        reverberate "exit" "1"
    fi
}

# installs a default configuration file
# this should not be required but if it does have to be configured it is nicer
# if it already exists
configure_plugins() {
    if [[ -d "${plugin_config_dir}" ]]; then
        if [[ ! -f  "${plugin_config_dir}/pihole.conf" ]]; then
            reverberate "info" "Installing the default plugin configuration"
            download "${plugin_repo}/etc/munin/plugin-conf.d/pihole.conf" -P "${plugin_config_dir}"
            reverberate "additional_info" "A copy of the default plugin configuration was installed"
            reverberate "success" "${plugin_config_dir}/pihole.conf"
        else
            if [[ "${force_update_plugin_config}" != "false" ]]; then
                if [[ -d "${external_config_dir}" ]]; then
                    reverberate "info" "Saving the existing pihole.conf plugin configuration file"
                    cp "${plugin_config_dir}/pihole.conf" "${external_config_dir}/pihole.conf.save" || return
                    reverberate "additional_info" "The existing pihole.conf file was saved to"
                    reverberate "success" "${external_config_dir}/pihole.conf.save"
                fi
                reverberate "info" "Updating the default plugin configuration"
                download "${plugin_repo}/etc/munin/plugin-conf.d/pihole.conf" -O "${plugin_config_dir}/pihole.conf"
                reverberate "additional_info" "The default plugin configuration was updated"
                reverberate "success" "${plugin_config_dir}/pihole.conf"
            fi
        fi
    else
        reverberate "error" "No Munin plugin configuration directory found"
        reverberate "failure" "${plugin_config_dir}"
        reverberate "additional_info" "If this directory is located at a different path try"
        reverberate "config" "PLUGIN_CONFIG_DIR"
        reverberate "exit" "1"
    fi
    if [[ "${pihole_on_host}" == "false" ]]; then
        reverberate "warning" "The Pi-hole® command 'pihole' was not found on this host"
        reverberate "additional_info" "If this was intentional you will need to edit"
        reverberate "${plugin_config_dir}/pihole.conf"
        reverberate "and replace the host and setupvars values with those of your Pi-hole® host"
    fi
}

# restart relevant services
restart_services() {
    case "${2}" in
        "-p" | "plugins" | "--plugins")
             exec env INSTALL_PLUGINS="true" INSTALL_WEBSERVER="false" /bin/bash "$0" "$1"
        ;;
        "-P" | "plugins-only" | "--plugins-only")
             exec env INSTALL_PLUGINS="true" INSTALL_WEBSERVER="false" SKIP_DEPENDENCY_CHECK="true" /bin/bash "$0" "$1"
        ;;
        "-w" | "webserver" | "--webserver")
             exec env INSTALL_PLUGINS="false" INSTALL_WEBSERVER="true" /bin/bash "$0" "$1"
        ;;
        "-W" | "webserver-only" | "--webserver-only")
             exec env INSTALL_PLUGINS="false" INSTALL_WEBSERVER="true" SKIP_DEPENDENCY_CHECK="true" /bin/bash "$0" "$1"
        ;;
        *)
            if [[ "${install_plugins}" == "true" ]]; then
                service_list+="${plugin_services}"
            fi
            if [[ "${install_webserver}" == "true" ]]; then
                service_list+="${webserver_services}"
            fi
            if [[ -n "${service_list}" ]]; then
                if i_can_has "service"; then
                    reverberate "info" "Restarting services"
                    for service_id in ${service_list}; do
                        # shellcheck disable=SC2143
                        if [[ -n "$(service "${service_id}" status | grep --ignore-case "active: active")" ]]; then
                            service "${service_id}" "restart"
                            reverberate "success" "${service_id}"
                        fi
                    done
                fi
            fi
        ;;
    esac
}

# installs the munin-pihole-plugins script on the host
# warn the user if script_dir is not in their path and suggest how to add it
install_script() {
    if [[ -d "${script_dir}" ]]; then
        reverberate "info" "Installing the munin-pihole-plugins script"
        if [[ -f "${script_dir}/munin-pihole-plugins" ]]; then
            download "${plugin_repo}/script/munin-pihole-plugins" -O "${script_dir}/munin-pihole-plugins"
        else
            download "${plugin_repo}/script/munin-pihole-plugins" -P "${script_dir}"
        fi
        chmod +x "${script_dir}/munin-pihole-plugins" || return
        reverberate "additional_info" "A copy of the munin-pihole-plugins script was installed"
        reverberate "success" "${script_dir}/munin-pihole-plugins"
        if [[ -d "/usr/local/man" ]]; then
            reverberate "info" "Installing the munin-pihole-plugins script manual"
            if [[ -f "${man_dir}/munin-pihole-plugins.1" ]] || [[ -f "${man_dir}/munin-pihole-plugins.1.gz" ]]; then
                download "${plugin_repo}/usr/local/man/man1/munin-pihole-plugins.1" -O "${man_dir}/munin-pihole-plugins.1"
            else
                download "${plugin_repo}/usr/local/man/man1/munin-pihole-plugins.1" -P "${man_dir}"
            fi
            reverberate "additional_info" "A copy of the munin-pihole-plugins manual was installed"
            reverberate "success" "${man_dir}/munin-pihole-plugins.1"
            if i_can_has "gzip" "noncritical"; then
                reverberate "additional_info" "Compressing the munin-pihole-plugins manual"
                gzip --force --quiet "${man_dir}/munin-pihole-plugins.1"
                reverberate "success" "${man_dir}/munin-pihole-plugins.1.gz"
            fi
            reverberate "additional_info" "To access the munin-pihole-plugins manual, type"
            reverberate "man munin-pihole-plugins"
        fi
        if [[ -d "/etc/bash_completion.d" ]]; then
            reverberate "info" "Installing the munin-pihole-plugins bash completion script"
            if [[ -f "/etc/bash_completion.d/munin-pihole-plugins" ]]; then
                download "${plugin_repo}/etc/bash_completion.d/munin-pihole-plugins" -O "/etc/bash_completion.d/munin-pihole-plugins"
            else
                download "${plugin_repo}/etc/bash_completion.d/munin-pihole-plugins" -P "/etc/bash_completion.d"
            fi
            reverberate "additional_info" "A copy of the munin-pihole-plugins bash-completion script was installed"
            reverberate "success" "/etc/bash_completion.d/munin-pihole-plugins"
            reverberate "additional_info" "To begin using it immediately, open a new terminal or type"
            reverberate ". /etc/bash_completion"
        fi
        if [[ ":${PATH}:" != *":${script_dir}:"* ]]; then
            reverberate "warning" "The munin-pihole-plugins script directory is not in your \$PATH"
            reverberate "failure" "\$PATH"
            reverberate "additional_info" "To add the munin-pihole-plugins script directory to your \$PATH try"
            reverberate "export PATH=\"\$PATH:${script_dir}\""
        else
            reverberate "additional_info" "The munin-pihole-plugins script directory is in your \$PATH"
            reverberate "success" "\$PATH"
            reverberate "additional_info" "You can now use munin-pihole-plugins just as you would any other command"
        fi
    else
        reverberate "error" "No directory found"
        reverberate "failure" "${script_dir}"
        reverberate "additional_info" "If this directory is located at a different path try"
        reverberate "config" "SCRIPT_DIR"
        reverberate "exit" "1"
    fi
}

# spawns a child script to uninstall a locally installed munin-pihole-plugins
# script if present
uninstall_script() {
    cat > "${temp_dir}/.munin-pihole-plugins_uninstall" << EOF
#!/usr/bin/env bash

# .munin-pihole-plugins_uninstall
# saint-lascivious (Hayden Pearce) 2022
# saint@sainternet.xyz

VERSION="${VERSION}"

# source current munin-pihole-plugins script to re-use its functions
# and environment
if [[ -f "${current_dir}/munin-pihole-plugins" ]]; then
    . "${current_dir}/munin-pihole-plugins"
else
    # this should never happen
    # but if it does we need to abort
    exit 1
fi

# uninstalls a locally installed copy of the munin-pihole-plugins script
uninstall_now() {
    reverberate "header"
    reverberate "runtime_disclaimer"
    if [[ -f "/etc/bash_completion.d/munin-pihole-plugins" ]]; then
        reverberate "info" "Removing the munin-pihole-plugins bash completion script"
        rm "/etc/bash_completion.d/munin-pihole-plugins" || return
        reverberate "success" "/etc/bash_completion.d/munin-pihole-plugins removed"
    fi
    if [[ -f "${man_dir}/munin-pihole-plugins.1" ]]; then
        reverberate "info" "Removing the munin-pihole-plugins manual"
        rm "${man_dir}/munin-pihole-plugins.1" || return
        reverberate "success" "${man_dir}/munin-pihole-plugins.1 removed"
    fi
    if [[ -f "${man_dir}/munin-pihole-plugins.1.gz" ]]; then
        reverberate "info" "Removing the munin-pihole-plugins manual"
        rm "${man_dir}/munin-pihole-plugins.1.gz" || return
        reverberate "success" "${man_dir}/munin-pihole-plugins.1.gz removed"
    fi
    if [[ "$(ls -A "${man_dir}")" ]]; then
        reverberate "additional_info" "The munin-pihole-plugins manual directory is empty"
        reverberate "info" "Removing the munin-pihole-plugins manual directory"
        if i_can_has "rmdir" "noncritical"; then
            rmdir "${man_dir}" || return
        else
            reverberate "additional_info" "\"rmdir\" unavailable, falling back to \"rm\""
            rm -r "${man_dir}" || return
        fi
        reverberate "success" "${man_dir} removed"
    fi
    if [[ -f "${external_config_dir}/${external_config_file}" ]]; then
        reverberate "info" "Removing munin-pihole-plugins external configuration"
        rm "${external_config_dir}/${external_config_file}" || return
        reverberate "success" "${external_config_dir}/${external_config_file} removed"
    fi
    if [[ "$(ls -A "${external_config_dir}")" ]]; then
        reverberate "additional_info" "The munin-pihole-plugins script external configuration directory is empty"
        reverberate "info" "Removing the munin-pihole-plugins script external configuration directory"
        if i_can_has "rmdir" "noncritical"; then
            rmdir "${external_config_dir}" || return
        else
            reverberate "additional_info" "\"rmdir\" unavailable, falling back to \"rm\""
            rm -r "${external_config_dir}" || return
        fi
        reverberate "success" "${external_config_dir} removed"
    fi
    if [[ -f "$(script_dir)/munin-pihole-plugins" ]]; then
        reverberate "info" "Removing the munin-pihole-plugins script"
        rm "${script_dir}/munin-pihole-plugins" || return
        reverberate "success" "${script_dir}/munin-pihole-plugins removed"
    reverberate "footer"
}

uninstall_now
EOF
    chmod +x "${temp_dir}/.munin-pihole-plugins_uninstall"
    exec /bin/bash "${temp_dir}/.munin-pihole-plugins_uninstall"
}

# an opportunistic pagination wrapper, more or less
# handles files and strings
# usage:
# some ["file"] "path to file or string to be paginated"
some() {
    case $1 in
        "file")
            if i_can_has "less" "noncritical"; then
                less --chop-long-lines --LONG-PROMPT --QUIT-AT-EOF --quit-if-one-screen --squeeze-blank-lines --tilde "$2"
            else
                reverberate "additional_info" "\"less\" unavailable, falling back to \"more\""
                if i_can_has "more" "noncritical"; then
                    more -d "$2"
                else
                    reverberate "error" "Unable to display the selected file reliably"
                    reverberate "info" "Install either \"less\" (recommended) or \"more\" and try again"
                fi
            fi
        ;;
        *)
            if i_can_has "less" "noncritical"; then
                echo -e "$@" | less --chop-long-lines --LONG-PROMPT --QUIT-AT-EOF --quit-if-one-screen --RAW-CONTROL-CHARS --squeeze-blank-lines --tilde
            else
                reverberate "additional_info" "\"less\" unavailable, falling back to \"more\""
                if i_can_has "more" "noncritical"; then
                    echo -e "$@" | more -d
                else
                    reverberate "additional_info" "\"more\" unavailable, falling back to \"echo\""
                    echo -e "$@"
                fi
            fi
        ;;
    esac
}

# check the version reported by munin-pihole-plugins.sainternet.xyz
# nslookup, as far as i am aware, has no analogue to dig's +short, so it
# requires a bunch of additional bullshit to strip the version from the txt
# record
# why tail 9, when we want 8 characters? fun fact: echo appends a newline
check_version() {
    if [[ "${branch}" == "master" ]]; then
        plugin_domain="munin-pihole-plugins.sainternet.xyz"
        plugin_repo="https://raw.githubusercontent.com/saint-lascivious/munin-pihole-plugins/master"
    else
        if [[ "${branch}" == "development" ]]; then
            plugin_domain="munin-pihole-plugins-dev.sainternet.xyz"
            plugin_repo="https://raw.githubusercontent.com/saint-lascivious/munin-pihole-plugins/development"
        else
            reverberate "error" "Invalid munin-pihole-plugins branch"
            reverberate "failure" "${branch}"
            reverberate "additional_info" "Valid munin-pihole-plugins branches are"
            reverberate "success" "development"
            reverberate "success" "master"
            reverberate "exit" "1"
        fi
    fi
    if i_can_has "dig" "noncritical"; then
        version_query="$(dig txt +short +timeout=5 +tries=2 "${plugin_domain}" @"${dns_server}" -p "${dns_port}" | sed s'/[^0-9.]//g')"
    else
        reverberate "additional_info" "\"dig\" unavailable, falling back to \"nslookup\""
        if i_can_has "nslookup"; then
            version_query="$(nslookup -port="${dns_port}" -retry=2 -timeout=5 -type=txt "${plugin_domain}" "${dns_server}" | grep '"version: [0-9].[0-9].[0-9]"' | sed s'/[^0-9.]//g' | tail -c 9)"
        fi
    fi
    if [[ -n "${version_query}" ]]; then
        remote_version="${version_query}"
    fi
}

# simple wrapper to set or reset config flags/vars in semi-arbitrary format
# handles creation of the external variable configuration file including path
# if required, split up from the labyrinthine mess that is config_function to
# limit some of the needless duplication that was happening there
# usage:
# 'transmogrify VAR VALUE [[/PATH/TO/]FILE] [SEPERATOR]'
# example: transmogrify "FOO" "BAR" "/PATH/TO/FILE" ": "
transmogrify() {
    external_var="$1"
    external_var_value="$2"
    if [[ -n "$3" ]]; then
        external_var_file="$3"
    else
        external_var_file="${external_config_dir}/${external_config_file}"
    fi
    if [[ -n "$4" ]]; then
        seperator="$4"
    else
        seperator="="
    fi
    if [[ ! -d "${external_config_dir}" ]]; then
        mkdir -p "${external_config_dir}" || return
    fi
    if [[ ! -f "${external_config_dir}/${external_config_file}" ]]; then
        cat > "${external_config_dir}/${external_config_file}" << EOF
# external configuration file created by $0
# ${rfc3339_date}

EOF
    fi
    case "$2" in
        "RESET")
            if grep -q "^${external_var}${seperator}" "${external_var_file}"; then
                sed -i "/^${external_var}/d" "${external_var_file}" || return
            fi
        ;;
        *)
            if grep -q "^${external_var}${seperator}" "${external_var_file}"; then
                sed -i "/^${external_var}${seperator}/c\\${external_var}${seperator}\"${external_var_value}\"" "${external_var_file}" || return
                some "${external_var}: ${external_var_value}"
            else
                echo "${external_var}${seperator}\"${external_var_value}\"" >> "${external_var_file}" || return
                some "${external_var}: ${external_var_value}"
            fi
        ;;
    esac
}

# display munin-pihole-plugins environment variables and their current values
# there were too many variables to list in the main help text
# triggers are available for popular DNS_SERVER values
# - cloudflare 1.1.1.1
# - comodo     8.26.56.26
# - google     8.8.8.8
# - localhost  127.0.0.1
# - opendns    208.67.222.222
# - quad9      9.9.9.9
config_function() {
    if [[ -n "$3" ]]; then
        external_var_list="BRANCH DNS_PORT DNS_SERVER EXTERNAL_CONFIG_DIR EXTERNAL_CONFIG_FILE FORCE_UPDATE_PLUGIN_CONFIG IGNORE_PIHOLE_ON_HOST INSTALL_PLUGINS INSTALL_SCRIPT INSTALL_WEBSERVER LIGHTTPD_WEBROOT MUNIN_BRANCH MUNIN_DIR MUNIN_CONFIG_DIR MUNIN_PLUGIN_DIR NODE_PLUGIN_DIR PLUGIN_CONFIG_DIR PLUGIN_LIST PROXY_CONFIG_DIR RESET_ALL SCRIPT_DIR SHOW_COLOUR SHOW_HEADER SKIP_DEPENDENCY_CHECK UPDATE_SELF VERBOSITY_LEVEL"
        for external_var_id in ${external_var_list}; do
            if [[ "$2" == "${external_var_id}" ]]; then
                if [[ -f "${script_dir}/munin-pihole-plugins" ]]; then
                    check_privilege "$@"
                    case "$3" in
                        "RESET")
                            transmogrify "$2" "RESET"
                        ;;
                        "CLOUDFLARE")
                            if [[ "$2" == "DNS_SERVER" ]]; then
                                transmogrify "$2" "1.1.1.1"
                            fi
                        ;;
                        "COMODO")
                            if [[ "$2" == "DNS_SERVER" ]]; then
                                transmogrify "$2" "8.26.56.26"
                            fi
                        ;;
                        "GOOGLE")
                            if [[ "$2" == "DNS_SERVER" ]]; then
                                transmogrify "$2" "8.8.8.8"
                            fi
                        ;;
                        "LOCALHOST")
                            if [[ "$2" == "DNS_SERVER" ]]; then
                                transmogrify "$2" "127.0.0.1"
                            fi
                        ;;
                        "OPENDNS")
                            if [[ "$2" == "DNS_SERVER" ]]; then
                                transmogrify "$2" "208.67.222.222"
                            fi
                        ;;
                        "QUAD9")
                            if [[ "$2" == "DNS_SERVER" ]]; then
                                transmogrify "$2" "9.9.9.9"
                            fi
                        ;;
                        *)
                            if [[ "$2" == "DNS_PORT" ]]; then
                                if [[ "$3" =~ ^[0-9]+$ ]]; then
                                    if [[ "$3" -ge "0" ]] && [[ "$3" -le "65535" ]]; then
                                        transmogrify "$2" "$3"
                                    else
                                        some "munin-pihole-plugins: $3 doesn't look like a port number
The DNS_PORT value must be from 0 to 65535"
                                    fi
                                else
                                    some "munin-pihole-plugins: $3 doesn't look like a port number
The DNS_PORT value must be from 0 to 65535"
                                fi
                            else
                                if [[ "$2" == "DNS_SERVER" ]]; then
                                    if [[ "$3" =~ ^(([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))\.){3}([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))$ ]]; then
                                        transmogrify "$2" "$3"
                                    else
                                        some "munin-pihole-plugins: $3 doesn't look like an IPv4 address
The DNS_SERVER value must be an IPv4 address from 0.0.0.0 to 255.255.255.255"
                                    fi
                                else
                                    transmogrify "$2" "$3"
                                fi
                            fi
                        ;;
                    esac
                else
                    some "munin-pihole-plugins: function unavailable
The munin-pihole-plugins script must be installed to use this function
Type \"munin-pihole-plugins --install --script\" to install it now"
                fi
            else
                if [[ "$2" == "RESET_ALL" ]]; then
                    for external_var in ${external_var_list}; do
                        transmogrify "${external_var}" "RESET"
                    done
                fi
            fi
        done
    else
        case "$2" in
            "BRANCH")
                some "BRANCH: ${branch}"
            ;;
            "DNS_PORT")
                some "DNS_PORT: ${dns_port}"
            ;;
            "DNS_SERVER")
                some "DNS_SERVER: ${dns_server}"
            ;;
            "EXTERNAL_CONFIG_DIR")
                some "EXTERNAL_CONFIG_DIR: ${external_config_dir}"
            ;;
            "EXTERNAL_CONFIG_FILE")
                some "EXTERNAL_CONFIG_FILE: ${external_config_file}"
            ;;
            "FORCE_UPDATE_PLUGIN_CONFIG")
                some "FORCE_UPDATE_PLUGIN_CONFIG: ${force_update_plugin_config}"
            ;;
            "HOLD_DURATION")
                some "HOLD_DURATION: ${hold_duration}"
            ;;
            "IGNORE_PIHOLE_ON_HOST")
                some "IGNORE_PIHOLE_ON_HOST: ${ignore_pihole_on_host}"
            ;;
            "INSTALL_PLUGINS")
                some "INSTALL_PLUGINS: ${install_plugins}"
            ;;
            "INSTALL_SCRIPT")
                some "INSTALL_SCRIPT: ${install_script}"
            ;;
            "INSTALL_WEBSERVER")
                some "INSTALL_WEBSERVER: ${install_webserver}"
            ;;
            "LIGHTTPD_WEBROOT")
                some "LIGHTTPD_WEBROOT: ${lighttpd_webroot}"
            ;;
            "MUNIN_BRANCH")
                some "MUNIN_BRANCH: ${munin_branch}"
            ;;
            "MUNIN_DIR")
                some "MUNIN_DIR: ${munin_dir}"
            ;;
            "MUNIN_CONFIG_DIR")
                some "MUNIN_CONFIG_DIR: ${munin_config_dir}"
            ;;
            "MUNIN_PLUGIN_DIR")
                some "MUNIN_PLUGIN_DIR: ${munin_plugin_dir}"
            ;;
            "NODE_PLUGIN_DIR")
                some "NODE_PLUGIN_DIR: ${node_plugin_dir}"
            ;;
            "PLUGIN_CONFIG_DIR")
                some "PLUGIN_CONFIG_DIR: ${plugin_config_dir}"
            ;;
            "PLUGIN_LIST")
                some "PLUGIN_LIST: ${plugin_list}
\\nPlugin          Description
 blocked         This plugin shows the number of domains blocked by Pi-hole®.
 cache           This plugin shows Pi-hole®'s cache.
 cache_by_type   This plugin shows Pi-hole®'s cache by type.
 clients         This plugin shows clients seen by Pi-hole®.
 percent         This plugin shows Pi-hole®'s blocked query percentage.
 privacy         This plugin shows Pi-hole®'s privacy level.
 queries         This plugin shows queries seen by Pi-hole®.
 queries_by_type This plugin shows Pi-hole®'s queries by type.
 replies_by_type This plugin shows Pi-hole®'s replies by type.
 status          This plugin shows Pi-hole®'s blocking status.
 unique_domains  This plugin shows unique domains seen by Pi-hole®."
            ;;
            "PROXY_CONFIG_DIR")
                some "PROXY_CONFIG_DIR: ${proxy_config_dir}"
            ;;
            "SCRIPT_DIR")
                some "SCRIPT_DIR: ${script_dir}"
            ;;
            "SHOW_COLOR"|"SHOW_COLOUR")
                some "SHOW_COLOUR: ${show_colour}"
            ;;
            "SHOW_HEADER")
                some "SHOW_HEADER: ${show_header}"
            ;;
            "SKIP_DEPENDENCY_CHECK")
                some "SKIP_DEPENDENCY_CHECK: ${skip_dependency_check}"
            ;;
            "UPDATE_SELF")
                some "UPDATE_SELF: ${update_self}"
            ;;
            "VERBOSITY_LEVEL")
                some "VERBOSITY_LEVEL: ${verbosity_level}"
            ;;
            "")
                if [[ -f "${script_dir}/munin-pihole-plugins" ]]; then
                    usage_text="Usage: munin-pihole-plugins $1 [VARIABLE [\"VALUE\"]]"
                    example_text="\\nExample: munin-pihole-plugins $1 DNS_SERVER LOCALHOST"
                else
                    usage_text="Usage: export VARIABLE=\"VALUE\""
                    example_text="\\nExample: export DNS_SERVER=\"127.0.0.1\""
                fi
                some "${usage_text}
\\nVariable
 BRANCH=\"${branch}\"
 DNS_PORT=\"${dns_port}\"
 DNS_SERVER=\"${dns_server}\"
 EXTERNAL_CONFIG_DIR=\"${external_config_dir}\"
 EXTERNAL_CONFIG_FILE=\"${external_config_file}\"
 FORCE_UPDATE_PLUGIN_CONFIG=\"${force_update_plugin_config}\"
 HOLD_DURATION=\"${hold_duration}\"
 IGNORE_PIHOLE_ON_HOST=\"${ignore_pihole_on_host}\"
 INSTALL_PLUGINS=\"${install_plugins}\"
 INSTALL_SCRIPT=\"${install_script}\"
 INSTALL_WEBSERVER=\"${install_webserver}\"
 LIGHTTPD_WEBROOT=\"${lighttpd_webroot}\"
 MUNIN_BRANCH=\"${munin_branch}\"
 MUNIN_DIR=\"${munin_dir}\"
 MUNIN_CONFIG_DIR=\"${munin_config_dir}\"
 MUNIN_PLUGIN_DIR=\"${munin_plugin_dir}\"
 NODE_PLUGIN_DIR=\"${node_plugin_dir}\"
 PLUGIN_CONFIG_DIR=\"${plugin_config_dir}\"
 PLUGIN_LIST=\"${plugin_list}\"
 PROXY_CONFIG_DIR=\"${proxy_config_dir}\"
 SCRIPT_DIR=\"${script_dir}\"
 SHOW_COLOUR=\"${show_colour}\"
 SHOW_HEADER=\"${show_header}\"
 SKIP_DEPENDENCY_CHECK=\"${skip_dependency_check}\"
 UPDATE_SELF=\"${update_self}\"
 VERBOSITY_LEVEL=\"${verbosity_level}\"
${example_text}"
           ;;
            *)
                some "munin-pihole-plugins: unrecognised variable \"${RED}$2${RESET}\"
Type \"munin-pihole-plugins --configure\" for a list of available variables"
        esac
    fi
}

debug_function() {
    if [[ "${install_plugins}" == "true" ]]; then
        if i_can_has "munin-run"; then
            check_privilege "$@"
            plugin_id="debug"
            if [[ -d "${munin_plugin_dir}" ]]; then
                if [[ -d "${node_plugin_dir}" ]]; then
                    reverberate "info" "Installing the munin-pihole-plugins debug plugin"
                    if [[ -f "${munin_plugin_dir}/pihole_" ]]; then
                        reverberate "additional_info" "Creating symbolic link pihole_${plugin_id}"
                        ln -s "${munin_plugin_dir}/pihole_" "${node_plugin_dir}/pihole_${plugin_id}" || return
                        reverberate "success" "${node_plugin_dir}/pihole_${plugin_id}"
                    else
                        reverberate "error" "No munin-pihole-plugins plugin found"
                        reverberate "failure" "${node_plugin_dir}/pihole_${plugin_id}"
                        reverberate "exit" "1"
                    fi
                else
                    reverberate "error" "No Munin node plugin directory found"
                    reverberate "failure" "${node_plugin_dir}"
                    reverberate "additional_info" "If this directory is located at a different path try"
                    reverberate "config" "NODE_PLUGIN_DIR"
                    reverberate "exit" "1"
                fi
            else
                reverberate "error" "No Munin plugin directory found"
                reverberate "failure" "${munin_plugin_dir}"
                reverberate "additional_info" "If this directory is located at a different path try"
                reverberate "config" "MUNIN_PLUGIN_DIR"
                reverberate "exit" "1"
            fi
            reverberate "info" "Executing debug plugin"
            munin-run "pihole_${plugin_id}"
            reverberate "additional_info" "Removing symbolic link pihole_${plugin_id}"
            rm "${node_plugin_dir}/pihole_${plugin_id}" || return
            reverberate "success" "${node_plugin_dir}/pihole_${plugin_id} removed"
        fi
    else
        reverberate "error" "INSTALL_PLUGINS value must be \"true\""
        reverberate "config" "INSTALL_PLUGINS"
        reverberate "exit" "0"
    fi
}

# display the munin-pihole-plugins script help text
# its sprawling nature is actually a good thing i guess
# interactive help is always better than a giant wall of text
help_function() {
    if [[ -f "${script_dir}/munin-pihole-plugins" ]]; then
        example_prefix="munin-pihole-plugins"
    else
        example_prefix="./munin-pihole-plugins"
    fi
    case "${2}" in
        "-c" | "--configure" | "configure")
            some "Usage: munin-pihole-plugins {$2 [RESET_ALL]|[VARIABLE [VALUE]]}
\\nOption             GNU long option      Function
 -c, configure      --configure          Display or set environment variables
\\nDisplay a full list of environment variables used by the munin-pihole-plugins
script, and their current values. These variables and this command can be used
to customize various aspects of the munin-pihole-plugins script's operation.
\\nTakes an optional parameter in the form of a munin-pihole-plugins environment
variable to list the value of that variable alone.
\\nExample: \"munin-pihole-plugins $2 INSTALL_PLUGINS\"
\\nTakes an optional value for a munin-pihole-plugins environment variable to
set the value of that variable. If the optional value passed is 'RESET', the
corresponding environment variable will be reset to its default value. This
functionality is only available if the munin-pihole-plugins script is found to
exist within 'SCRIPT_DIR'.
\\nExamples: \"${example_prefix} $2 DNS_SERVER 127.0.0.1\"
          \"${example_prefix} $2 DNS_SERVER RESET\"
\\nTakes an optional parameter in the form of 'RESET_ALL' to restore all
munin-pihole-plugins environment variables to their default values. Again,
this functionality is only available if the munin-pihole-plugins script is
found to exist within 'SCRIPT_DIR', whereby it's considered \"installed\".
\\nExample: \"${example_prefix} $2 RESET_ALL\""
        ;;
        "-d" | "--debug" | "debug")
            some "Usage: munin-pihole-plugins {$2}
\\nOption             GNU long option      Function
 -d, debug          --debug              Install and run the debug plugin
\\nInstall and run the debug plugin to examine the current plugin environment.
The plugin is executed once using \"munin-run\" and then removed afterward.
\\nNote: This plugin does not configure or produce any graph.
\\nExample: \"${example_prefix} $2\""
        ;;
        "-h" | "--help" | "help")
            some "Usage: munin-pihole-plugins $2 {OPTION[PARAMETER]}
\\nOption             GNU long option      Function
 -h, help           --help               Display this and other help dialogues
\\nDisplay simple or detailed munin-pihole-plugins help information.
Type \"${example_prefix} $2 {OPTION [PARAMETER]}\" for more detailed
explanations of each command.
\\nExample: \"${example_prefix} $2 --install --plugins\""
        ;;
        "-i" | "--install" | "install")
            case "${3}" in
                "-p" | "--plugins" | "plugins")
                    some "Usage: munin-pihole-plugins {$2 [PARAMETER]}
\\nParameter          GNU long parameter   Function
 -p, plugins        --plugins            Install and configure munin-node, and
                                         munin-pihole-plugins plugins
\\nExample: \"${example_prefix} $2 $3\""
                ;;
                "-s" | "--script" | "script")
                    some "Usage: munin-pihole-plugins {$2 [PARAMETER]}
\\nParameter          GNU long parameter   Function
 -s, script         --script             Install the munin-pihole-plugins
                                         script
\\nExample: \"${example_prefix} $2 $3\""
                ;;
                "-w" | "--webserver" | "webserver")
                    some "Usage: munin-pihole-plugins {$2 [PARAMETER]}
\\nParameter          GNU long parameter   Function
 -w, webserver      --webserver          Install and configure munin, lighttpd
                                         and lighttpd-external-munin-proxy
\\nExample: \"${example_prefix} $2 $3\""
                ;;
                "-P" | "--plugins-only" | "plugins-only")
                    some "Usage: munin-pihole-plugins {$2 [PARAMETER]}
\\nParameter          GNU long parameter   Function
 -P, plugins-only   --plugins-only       Install munin-pihole-plugins
                                         plugins
\\nExample: \"${example_prefix} $2 $3\""
                ;;
                "-S" | "--script-only" | "script-only")
                    some "Usage: munin-pihole-plugins {$2 [PARAMETER]}
\\nParameter          GNU long parameter   Function
 -S, script-only    --script-only        Install the munin-pihole-plugins
                                         script
\\nExample: \"${example_prefix} $2 $3\""
                ;;
                "-W" | "--webserver-only" | "webserver-only")
                    some "Usage: munin-pihole-plugins {$2 [PARAMETER]}
\\nParameter          GNU long parameter   Function
 -W, webserver-only --webserver-only     Install lighttpd-external-munin-proxy
\\nExample: \"${example_prefix} $2 $3\""
                ;;
                *)
                    some "Usage: munin-pihole-plugins {$2 [PARAMETER]}
\\nOption             GNU long option      Function
 -i, install        --install            Install munin-pihole-plugins
\\nInstall and configure Munin monitoring server software (default: true), client
software (default: true), selected munin-pihole-plugins plugins (default: all)
and install a copy of the munin-pihole-plugins script (default: true) to a
selected directory (default: /usr/local/bin).
\\nThe munin-pihole-plugins script will self update (default: true) before install
if a newer version of the munin-pihole-plugins script is available.
\\nYou can run the installation again at any time afterwards to update the
munin-pihole-plugins script and plugins, optionally selecting which plugins to
install using the PLUGIN_LIST variable.
\\nTakes an optional parameter to install just that component.
\\nParameter          GNU long parameter   Function
 -p, plugins        --plugins            Install and configure munin-node, and
                                         munin-pihole-plugins plugins
 -P, plugins-only   --plugins-only       As above, skipping dependency check
 -s, script         --script             Install the munin-pihole-plugins
                                         script
 -S, script-only    --script-only        As above, skipping dependency check
 -w, webserver      --webserver          Install and configure munin, lighttpd
                                         and lighttpd-external-munin-proxy
 -W, webserver-only --webserver-only     As above, skipping dependency check
\\nExample: \"${example_prefix} $2 --plugins\""
                ;;
            esac
        ;;
        "-r" | "restart" | "--restart")
            case "${3}" in
                "-p" | "--plugins" | "plugins")
                    some "Usage: munin-pihole-plugins {$2 [PARAMETER]}
\\nParameter          GNU long parameter   Function
 -p, plugins        --plugins            Restart the munin-node service
\\nExample: \"${example_prefix} $2 $3\""
                ;;
                "-w" | "--webserver" | "webserver")
                    some "Usage: munin-pihole-plugins {$2 [PARAMETER]}
\\nParameter          GNU long parameter   Function
 -w, webserver      --webserver          Restart both the munin and lighttpd
                                         services
\\nExample: \"${example_prefix} $2 $3\""
                ;;
                *)
                    some "Usage: munin-pihole-plugins {$2 [PARAMETER]}
\\nOption             GNU long option      Function
 -r, restart        --restart            Restart munin-pihole-plugins services
\\nRestart any/all services relevant to munin-pihole-plugins.
\\nThe list of services to restart is governed by the states of the \"INSTALL_*\"
environment/external configuration variables, all of which default \"true\".
\\nTakes an optional parameter to restart only those services involved with
that munin-pihole-plugins component.
\\nParameter          GNU long parameter   Function
 -p, plugins        --plugins            Restart the munin-node service
 -w, webserver      --webserver          Restart both the munin and lighttpd
                                         services
\\nExample: \"${example_prefix} $2\""
            esac
        ;;
        "-s" | "show" | "--show")
            case "${3}" in
                "-c" | "conditions" | "--conditions")
                    some "Usage: munin-pihole-plugins {$2 OPTION}
\\nDisplay munin-pihole-plugins GNU GPL licensing conditions.
\\nExample: \"${example_prefix} $2 --conditions\""
                ;;
                "-g" | "gnu-gpl" | "--gnu-gpl")
                    some "Usage: munin-pihole-plugins {$2 OPTION}
\\nDisplay the full GNU GPL v3 license text, a very large file.
\\nRequires one of either \"less\" (preferred) or \"more\" terminal paginator
packages.
\\nExample: \"${example_prefix} $2 --gnu-gpl\""
                ;;
                "-l" | "liability" | "--liability")
                    some "Usage: munin-pihole-plugins {$2 OPTION}
\\nDisplay munin-pihole plugins liability definition.
\\nExample: \"${example_prefix} $2 --liability\""
                ;;
                "-w" | "warranty" | "--warranty")
                    some "Usage: munin-pihole-plugins {$2 OPTION}
\\nDisplay munin-pihole plugins warranty information.
\\nExample: \"${example_prefix} $2 --warranty\""
                ;;
                *)
                    some "Usage: munin-pihole-plugins {$2 OPTION}
\\nOption             GNU long option      Function
 -s, show           --show               Display GNU GPLv3 license information

Option             GNU long option      Function
 -c, conditions     --conditions         Show GNU GPLv3 licensing conditions
 -g, gnu-gpl        --gnu-gpl            Show full GNU GPL v3 license text
                                         (less/more terminal paginator required)
 -l, liability      --liability          Show liability definition
 -w, warranty       --warranty           Show warranty information
\\nExample: \"${example_prefix} $2 --warranty\""
                ;;
            esac
        ;;
        "-u" | "--uninstall" | "uninstall")
            case "${3}" in
                "-p" | "--plugins" | "plugins")
                    some "Usage: munin-pihole-plugins {$2 [PARAMETER]}
\\nParameter          GNU long parameter   Function
 -p, plugins        --plugins            Uninstall muninin-pihole-plugins
                                         plugins
\\nExample: \"${example_prefix} $2 $3\""
                ;;
                "-s" | "--script" | "script")
                    some "Usage: munin-pihole-plugins {$2 [PARAMETER]}
\\nParameter          GNU long parameter   Function
 -s, script         --script             Uninstall the munin-pihole-plugins
                                         script
\\nExample: \"${example_prefix} $2 $3\""
                ;;
                "-w" | "--webserver" | "webserver")
                    some "Usage: munin-pihole-plugins {$2 [PARAMETER]}
\\nParameter          GNU long parameter   Function
 -w, webserver      --webserver          Uninstall munin, lighttpd, and
                                         lighttpd-external-munin-proxy
\\nExample: \"${example_prefix} $2 $3\""
                ;;
                "-P" | "--plugins-only" | "plugins-only")
                    some "Usage: munin-pihole-plugins {$2 [PARAMETER]}
\\nParameter          GNU long parameter   Function
 -P, plugins-only   --plugins-only       Uninstall munin-pihole-plugins
                                         plugins
\\nExample: \"${example_prefix} $2 $3\""
                ;;
                "-S" | "--script-only" | "script-only")
                    some "Usage: munin-pihole-plugins {$2 [PARAMETER]}
\\nParameter          GNU long parameter   Function
 -S, script-only    --script-only        Uninstall the munin-pihole-plugins
                                         script
\\nExample: \"${example_prefix} $2 $3\""
                ;;
                "-W" | "--webserver-only" | "webserver-only")
                    some "Usage: munin-pihole-plugins {$2 [PARAMETER]}
\\nParameter          GNU long parameter   Function
 -W, webserver-only --webserver-only     Uninstall lighttpd-external-munin-proxy
\\nExample: \"${example_prefix} $2 $3\""
                ;;
                *)
                    some "Usage: munin-pihole-plugins {$2 [PARAMETER]}
\\nOption             GNU long option      Function
 -u, uninstall       --uninstall         Uninstall munin-pihole-plugins
\\nCompletely uninstall munin-pihole-plugins, you will be asked if you want to
uninstall any dependencies that munin-pihole-plugins may have installed.
\\nTakes an optional parameter to uninstall just that component.
\\nParameter          GNU long parameter   Function
 -p, plugins        --plugins            Uninstall munin-node, and
                                         munin-pihole-plugins plugins
 -P, plugins-only   --plugins-only       As above, skipping dependency removal
 -s, script         --script             Uninstall the munin-pihole-plugins
                                         script
 -S, script-only    --script-only        As above, skipping dependency removal
 -w, webserver      --webserver          Uninstall munin, lighttpd, and
                                         lighttpd-external-munin-proxy
 -W, webserver-only --webserver-only     As above, skipping dependency removal
\\nExample: \"${example_prefix} $2 --script-only\""
                ;;
            esac
        ;;
        "-v" | "--version" | "version")
            some "Usage: munin-pihole-plugins {$2}
\\nOption             GNU long option      Function
 -v, version        --version            Display current and latest versions
\\nDisplay the current munin-pihole-plugins script version, and compare it to
the latest munin-pihole-plugins script version.
\\nAn additional notification will be displayed if an update is available."
        ;;
        "")
            some "Usage: munin-pihole-plugins {OPTION [PARAMETER]}
Option             GNU long option      Function
 -c, configure      --configure          Display or set environment variables
 -d, debug          --debug              Install and run the debug plugin
 -h, help           --help               Display this and other help dialogues
 -i, install        --install            Install munin-pihole-plugins
 -r, restart        --restart            Restart munin-pihole-plugins services
 -s, show           --show               Display GNU GPLv3 license information
 -u, uninstall      --uninstall          Uninstall munin-pihole-plugins
 -v, version        --version            Display current and latest versions

Type \"${example_prefix} --help {OPTION [PARAMETER]}\" for more detailed
explanations of each command.
\\nExample: \"${example_prefix} $1 --install --plugins\""
        ;;
        *)
            some "munin-pihole-plugins: unrecognised option \"${RED}$2${RESET}\"
Type \"${example_prefix} --help\" for a list of available options"
        ;;
    esac
}

# primary installation function, installation exceptions are handled here
install_function() {
    case "${2}" in
        "-p" | "plugins" | "--plugins")
             exec env INSTALL_SCRIPT="false" INSTALL_WEBSERVER="false" /bin/bash "$0" "$1"
        ;;
        "-P" | "plugins-only" | "--plugins-only")
             exec env INSTALL_SCRIPT="false" INSTALL_WEBSERVER="false" SKIP_DEPENDENCY_CHECK="true" /bin/bash "$0" "$1"
        ;;
        "-s" | "script" | "--script")
             exec env INSTALL_PLUGINS="false" INSTALL_WEBSERVER="false" /bin/bash "$0" "$1"
        ;;
        "-S" | "script-only" | "--script-only")
             exec env INSTALL_PLUGINS="false" INSTALL_WEBSERVER="false" SKIP_DEPENDENCY_CHECK="true" /bin/bash "$0" "$1"
        ;;
        "-w" | "webserver" | "--webserver")
             exec env INSTALL_PLUGINS="false" INSTALL_SCRIPT="false" /bin/bash "$0" "$1"
        ;;
        "-W" | "webserver-only" | "--webserver-only")
             exec env INSTALL_PLUGINS="false" INSTALL_SCRIPT="false" SKIP_DEPENDENCY_CHECK="true" /bin/bash "$0" "$1"
        ;;
        *)
            if [[ ! "${install_plugins}" == "true" ]] && [[ ! "${install_script}" == "true" ]] && [[ ! "${install_webserver}" == "true" ]]; then
                reverberate "error" "No action(s) to perform"
                reverberate "info" "At least one INSTALL_* variable must be \"true\""
                reverberate "exit" "1"
            fi
            check_privilege "$@"
            check_version
            if [[ "${update_self}" == "true" ]]; then
                if [[ -f "${temp_dir}/.munin-pihole-plugins_update" ]]; then
                    rm "${temp_dir}/.munin-pihole-plugins_update" || return
                fi
                if [[ "${remote_version}" != "${VERSION}" ]]; then
                    update_script "$@"
                fi
            fi
            reverberate "header"
            reverberate "runtime_disclaimer"
            if [[ "${skip_dependency_check}" == "false" ]]; then
                install_dependencies
            else
                reverberate "info" "Skipping dependency checks"
            fi
            if [[ "${install_plugins}" == "true" ]]; then
                if [[ -n "${plugin_list}" ]]; then
                    check_pihole
                    uninstall_plugins
                    install_plugins
                    configure_plugins
                else
                    reverberate "error" "No action(s) to perform"
                    reverberate "info" "No plugins in PLUGIN_LIST"
                    reverberate "exit" "1"
                fi
            else
                reverberate "info" "Skipping plugin installation"
            fi
            if [[ "${install_webserver}" == "true" ]]; then
                if [[ "${munin_branch}" == "stable" ]]; then
                    configure_munin
                fi
                configure_proxy
            else
                reverberate "info" "Skipping webserver installation"
            fi
            restart_services "$@"
            if [[ "${install_script}" == "true" ]]; then
                install_script
            else
                reverberate "info" "Skipping script installation"
            fi
            reverberate "footer"
        ;;
    esac
}

# GNU GPL v3 license magic for the sake of completion
# spits out some boilerplate that's technically required
# (and a little that isn't {-l,liability,--liability})
gnugpl_info_function() {
    if [[ -f "${script_dir}/munin-pihole-plugins" ]]; then
        example_prefix="munin-pihole-plugins"
    else
        example_prefix="./munin-pihole-plugins"
    fi
    case "${2}" in
        "-c" | "conditions" | "--conditions")
            some "munin-pihole-plugins saint-lascivious (Hayden Pearce) ©2022
\\n  This program is ${GREEN}FREE SOFTWARE${RESET}: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.
\\n  This program is distributed in the hope that it will be useful,
  but ${RED}WITHOUT ANY WARRANTY${RESET}; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
\\n  To read the full GNU GPL v3 license text, type
  \"${example_prefix} --show --gnu-gpl\"
\\nContact: munin-pihole-plugins@sainternet.xyz"
        ;;
        "-g" | "gnu-gpl" | "--gnu-gpl")
            download "${gnu_gpl_v3}" -O "${temp_dir}/.munin-pihole-plugins_license"
            some "file" "${temp_dir}/.munin-pihole-plugins_license"
            rm "${temp_dir}/.munin-pihole-plugins_license"
        ;;
        "-l" | "liability" | "--liability")
            some "munin-pihole-plugins saint-lascivious (Hayden Pearce) ©2022
\\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
  THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
  GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
  USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
  DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
  PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
  EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
\\n  To read the full GNU GPL v3 license text, type
  \"${example_prefix} --show --gnu-gpl\"
\\nContact: munin-pihole-plugins@sainternet.xyz"
        ;;
        "-w" | "warranty" | "--warranty")
            some "munin-pihole-plugins saint-lascivious (Hayden Pearce) ©2022
\\n  THERE IS ${RED}NO WARRANTY${RESET} FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
  APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
  HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" ${RED}WITHOUT WARRANTY
  OF ANY KIND${RESET}, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
  IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
  ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
\\n  To read the full GNU GPL v3 license text, type
  \"${example_prefix} --show --gnu-gpl\"
\\nContact: munin-pihole-plugins@sainternet.xyz"
        ;;
        *)
            some "munin-pihole-plugins: unrecognised option \"${RED}$2${RESET}\"
\\nFor a list of available options, type
\"${example_prefix} --help --show\""
        ;;
    esac
}

# uninstall munin-pihole-plugins
# removes all munin plugins and related configuration placed by
# munin-pihole-plugins and then prompts to remove any dependencies that may
# have been installed by munin-pihole-plugins (since we don't track what we
# did install if anything)
# places a blank external.conf file for lighttpd if we can't restore a backup
# because apparently it will pitch a fit if external.conf doesn't exist
uninstall_function() {
    case "${2}" in
        "-p" | "plugins" | "--plugins")
             exec env INSTALL_SCRIPT="false" INSTALL_WEBSERVER="false" /bin/bash "$0" "$1"
        ;;
        "-P" | "plugins-only" | "--plugins-only")
             exec env INSTALL_SCRIPT="false" INSTALL_WEBSERVER="false" SKIP_DEPENDENCY_CHECK="true" /bin/bash "$0" "$1"
        ;;
        "-s" | "script" | "--script")
             exec env INSTALL_PLUGINS="false" INSTALL_WEBSERVER="false" /bin/bash "$0" "$1"
        ;;
        "-S" | "script-only" | "--script-only")
             exec env INSTALL_PLUGINS="false" INSTALL_WEBSERVER="false" SKIP_DEPENDENCY_CHECK="true" /bin/bash "$0" "$1"
        ;;
        "-w" | "webserver" | "--webserver")
             exec env INSTALL_PLUGINS="false" INSTALL_SCRIPT="false" /bin/bash "$0" "$1"
        ;;
        "-W" | "webserver-only" | "--webserver-only")
             exec env INSTALL_PLUGINS="false" INSTALL_SCRIPT="false" SKIP_DEPENDENCY_CHECK="true" /bin/bash "$0" "$1"
        ;;
        *)
            if [[ ! "${install_plugins}" == "true" ]] && [[ ! "${install_script}" == "true" ]] && [[ ! "${install_webserver}" == "true" ]]; then
                reverberate "warning" "No installation action(s) to perform"
                reverberate "info" "At least one INSTALL_* variable must be \"true\""
                reverberate "exit" "0"
            fi
            check_privilege "$@"
            reverberate "header"
            reverberate "runtime_disclaimer"
            if [[ "${install_plugins}" == "true" ]]; then
                dependency_list+="munin-node "
                if [[ -d "${plugin_config_dir}" ]]; then
                    if [[ -f  "${plugin_config_dir}/pihole.conf" ]]; then
                        rm "${plugin_config_dir}/pihole.conf" || return
                    fi
                fi
                uninstall_plugins
            fi
            if [[ "${install_script}" == "true" ]]; then
                dependency_list+="wget "
            fi
            if [[ "${install_webserver}" == "true" ]]; then
                check_pihole
                if [[ "${pihole_on_host}" == "true" ]]; then
                    if [[ -d "${lighttpd_webroot}/pihole" ]]; then
                        dependency_list+="munin "
                    else
                        dependency_list+="${webserver_dependencies}"
                    fi
                else
                    dependency_list+="${webserver_dependencies}"
                fi
                if [[ -d "${proxy_config_dir}" ]]; then
                    if [[ -f "${proxy_config_dir}/external.conf.orig" ]]; then
                        mv "${proxy_config_dir}/external.conf.orig" "${proxy_config_dir}/external.conf" || return
                        reverberate "info" "Original lighttpd external.conf restored from backup"
                    else
                        if [[ -f "${proxy_config_dir}/external.conf" ]]; then
                            rm "${proxy_config_dir}/external.conf" || return
                            touch "${proxy_config_dir}/external.conf" || return
                        fi
                    fi
                fi
                if [[ -d "${munin_config_dir}" ]]; then
                    if [[ -f "${munin_config_dir}/99-graph-strategy.conf" ]]; then
                        rm "${munin_config_dir}/99-graph-strategy.conf" || return
                    fi
                else
                    if [[ -d "${munin_dir}" ]]; then
                        if [[ -f "${munin_dir}/munin.conf" ]]; then
                            sed -i "s/^html_strategy cli/#html_strategy cron/g" "${munin_dir}/munin.conf" || return
                            sed -i "s/^graph_strategy cli/#graph_strategy cron/g" "${munin_dir}/munin.conf" || return
                        fi
                    fi
                fi
            fi
            if [[ "${skip_dependency_check}" == "false" ]]; then
                if i_can_has "dpkg-query"; then
                    if i_can_has "apt"; then
                        for dependency_id in ${dependency_list}; do
                            package_query="$(dpkg-query -W --showformat='${Status}\n' "${dependency_id}" | grep "install ok installed")"
                            if [[ -n "${package_query}" ]]; then
                                reverberate "info" "${dependency_id} may have been installed by munin-pihole-plugins"
                                reverberate "question" "Would you like to uninstall ${dependency_id} now?"
                                if [[ "${dependency_id}" == "curl" ]] ||  [[ "${dependency_id}" == "init-system-helpers" ]] || [[ "${dependency_id}" == "wget" ]]; then
                                    reverberate "warning" "It probably wasn't, and you probably wouldn't"
                                fi
                                reverberate "info" "Uninstalling package ${dependency_id}"
                                if [[ "${verbosity_level}" -ge "2" ]]; then
                                    apt remove -q "${dependency_id}"
                                else
                                    apt remove -qq "${dependency_id}" > /dev/null 2>&1
                                fi
                                reverberate "success" "${dependency_id}"
                            fi
                        done
                    fi
                fi
            fi
            if [[ "${install_script}" == "true" ]]; then
                if [[ -d "${script_dir}" ]]; then
                    if [[ -f "${script_dir}/munin-pihole-plugins" ]]; then
                        uninstall_script
                    fi
                fi
            else
                reverberate "footer"
            fi
        ;;
    esac
}

# display the current and latest munin-pihole-plugins script versions
# mimics reverberate in most regards except the current <-> remote version
# output is displayed at any verbosity level
# basically reverberate, but keeping opportunistic interactive pagination
version_function() {
    check_version
    if [[ -n "${remote_version}" ]]; then
        if [[ "${verbosity_level}" -ge "3" ]]; then
            update_notification="  [${WHITE}ℹ${RESET}] ${GREEN}An update for munin-pihole-plugins is available${RESET}\\n"
        fi
        if [[ -n "${BRANCH}" ]] && [[ "${BRANCH}" != "${branch}" ]]; then
            if [[ "${verbosity_level}" -ge "2" ]]; then
                branch_warning="  [${YELLOW}⚠${RESET}] ${YELLOW}Current and remote branches differ${RESET}\\n"
            fi
            if [[ "${branch}" == "master" ]]; then
                if [[ "${remote_version}" > "${VERSION}" ]]; then
                    some "${branch_warning}${update_notification}  [${WHITE}ℹ${RESET}] ${GREEN}munin-pihole-plugins version is ${RED}v${VERSION}${GREEN} (Latest: v${remote_version})${RESET}"
                else
                    some "  [${WHITE}ℹ${RESET}] ${GREEN}munin-pihole-plugins version is v${VERSION} (Latest: v${remote_version})${RESET}"
                fi
            else
                if [[ "${branch}" == "development" ]]; then
                    if [[ "${remote_version}" != "${VERSION}" ]]; then
                        some "${branch_warning}${update_notification}  [${WHITE}ℹ${RESET}] ${GREEN}munin-pihole-plugins version is v${VERSION} (Latest: ${RED}v${remote_version}${GREEN})${RESET}"
                    else
                        some "  [${WHITE}ℹ${RESET}] ${GREEN}munin-pihole-plugins version is v${VERSION} (Latest: v${remote_version})${RESET}"
                    fi
                fi
            fi
        else
            if [[ "${remote_version}" > "${VERSION}" ]]; then
                    some "${update_notification}  [${WHITE}ℹ${RESET}] ${GREEN}munin-pihole-plugins version is ${RED}v${VERSION}${GREEN} (Latest: v${remote_version})${RESET}"
            else
                    some "  [${WHITE}ℹ${RESET}] ${GREEN}munin-pihole-plugins version is v${VERSION} (Latest: v${remote_version})${RESET}"
            fi
        fi
    else
        if [[ "${verbosity_level}" -ge "1" ]]; then
            dns_error="\\n [${RED}!${RESET}]  ${RED}Unable to locate TXT record${RESET}"
        else
            if [[ "${verbosity_level}" -ge "4" ]]; then
                authoritative_hint="\\n  [${WHITE}ℹ${RESET}] ${GREEN}Authoritative records available at \"dns.sainternet.xyz\"${RESET}"
            fi
        fi
        some "${dns_error}  [${YELLOW}⚠${RESET}] ${YELLOW}Unable to locate TXT record for \"${plugin_domain}\"${RESET}
  using the nameserver \"${dns_server}\" on port \"${dns_port}\"${authoritative_hint}
\\n  [${WHITE}ℹ${RESET}] ${GREEN}munin-pihole-plugins version is v${VERSION} (Latest: ${RED}unknown${GREEN})${RESET}"
    fi
}

# function handler
# whinges about being run with no input
# whinges about being run with invalid input
function_handler() {
    case "${1}" in
        "-c" | "--configure" | "configure")
            config_function "$@"
        ;;
        "-d" | "debug" | "--debug")
            debug_function "$@"
        ;;
        "-h" | "--help" | "help")
            help_function "$@"
        ;;
        "-i" | "--install" | "install")
            install_function "$@"
        ;;
        "-r" | "restart" | "--restart")
            restart_services "$@"
        ;;
        "-s" | "show" | "--show")
            gnugpl_info_function "$@"
        ;;
        "-u" | "--uninstall" | "uninstall")
            uninstall_function "$@"
        ;;
        "-v" | "--version" | "version")
            version_function "$@"
        ;;
        "")
        ;;
        *)
            if [[ -f "${man_dir}/munin-pihole-plugins.1" ]] || [[ -f "${man_dir}/munin-pihole-plugins.1.gz" ]]; then
                manual_text=", or type
\"man munin-pihole-plugins\" to access the munin-pihole-plugins manual"
            fi
            some "munin-pihole-plugins: unrecognised option \"${RED}$1${RESET}\"
\\nType \"munin-pihole-plugins --help\" for a list of available options${manual_text}"
        ;;
    esac
}

function_handler "$@"
